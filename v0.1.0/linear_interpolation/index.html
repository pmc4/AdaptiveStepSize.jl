<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear interpolation · AdaptiveStepSize.jl</title><meta name="title" content="Linear interpolation · AdaptiveStepSize.jl"/><meta property="og:title" content="Linear interpolation · AdaptiveStepSize.jl"/><meta property="twitter:title" content="Linear interpolation · AdaptiveStepSize.jl"/><meta name="description" content="Documentation for AdaptiveStepSize.jl."/><meta property="og:description" content="Documentation for AdaptiveStepSize.jl."/><meta property="twitter:description" content="Documentation for AdaptiveStepSize.jl."/><meta property="og:url" content="https://pmc4.github.io/AdaptiveStepSize.jl/linear_interpolation/"/><meta property="twitter:url" content="https://pmc4.github.io/AdaptiveStepSize.jl/linear_interpolation/"/><link rel="canonical" href="https://pmc4.github.io/AdaptiveStepSize.jl/linear_interpolation/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AdaptiveStepSize.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Usage</span><ul><li class="is-active"><a class="tocitem" href>Linear interpolation</a><ul class="internal"><li><a class="tocitem" href="#Singularities"><span>Singularities</span></a></li><li><a class="tocitem" href="#Piecewise-functions"><span>Piecewise functions</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../theory/">Theory</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Usage</a></li><li class="is-active"><a href>Linear interpolation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear interpolation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/pmc4/AdaptiveStepSize.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/pmc4/AdaptiveStepSize.jl/blob/main/docs/src/linear_interpolation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Linear-interpolation"><a class="docs-heading-anchor" href="#Linear-interpolation">Linear interpolation</a><a id="Linear-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-interpolation" title="Permalink"></a></h1><p>To compute the points of a linear interpolation for a given function <span>$f(x)$</span>, we can use the <a href="#AdaptiveStepSize.points_linear"><code>points_linear</code></a> function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AdaptiveStepSize.points_linear" href="#AdaptiveStepSize.points_linear"><code>AdaptiveStepSize.points_linear</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">points_linear(f, domain, tol::T; scan_step = (domain[end] - domain[begin]) / 100) where T &lt;: Real</code></pre><p>Computes points used for a linear interpolation of the function <code>f</code> in the given <code>domain</code> within a tolerance <code>tol</code>.</p><p>See also <a href="#AdaptiveStepSize.points_linear_singular"><code>points_linear_singular</code></a> for managing singular points.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The function used for the linear interpolation. It must be of the form of f(x), where <code>x</code> is a number.</li><li><code>domain</code>: a tuple or array representing the interpolation domain, e.g., the tuple (a, b).</li><li><code>tol::T where T &lt;: Real</code>: the desired tolerance of the points. The real value of the function at any point xᵢ minus the aproximation will be smaller than <code>tol</code>, i.e., |f(xᵢ) - yᵢ| &lt; tol.</li></ul><p><strong>Keywords</strong></p><ul><li><code>scan_step</code>: Minimum step size that will be used to scan the whole domain. The returned points will have at least a spacing of <code>scan_step</code>. Very small values will produce a very long execution time. By default it will divide the domain in 100 intervals.</li></ul><p><strong>Returns</strong></p><ul><li><code>(xs, ys)</code>: A tuple containing two arrays of points, <code>xs</code> for the independent variable and <code>ys</code> for the computed values of the function.</li></ul><p><strong>Notes</strong></p><p>The function <code>f</code> must have a continuous second derivative in order to compute the linear interpolation error. This second derivative is computed using <code>Enzyme</code>&#39;s automatic differentiation.</p><p>If the returned <code>(xs, ys)</code> contains just the endpoints, try decreasing the <code>scan_step</code> size and/or increasing the tolerance <code>tol</code>.</p><p>If the execution time of a single call to the function <code>f</code> is quite long, this adaptive method might not be suitable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pmc4/AdaptiveStepSize.jl/blob/4eadb5435284d03585c56f504bc108545203d4e0/src/AdaptiveStepSize.jl#L20-L49">source</a></section></article><p>For example, let us apply this function to <span>$f(x) = \sqrt{2x}$</span> on the interval <span>$[0,\, 2]$</span> with a tolerance of <span>$10^{-2}$</span>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using AdaptiveStepSize</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x) = 2 * sqrt(x)</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain = (0.0, 2.0)</code><code class="nohighlight hljs ansi" style="display:block;">(0.0, 2.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tol = 1e-2</code><code class="nohighlight hljs ansi" style="display:block;">0.01</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; xs, ys = points_linear(f, domain, tol; scan_step = 1e-4)</code><code class="nohighlight hljs ansi" style="display:block;">([0.0, 0.0004, 0.0018000000000000006, 0.005500000000000001, 0.013699999999999973, 0.029899999999999875, 0.05880000000000066, 0.10670000000000203, 0.18149999999999633, 0.2927999999999841, 0.45209999999996653, 0.6726999999999422, 0.9698999999999095, 1.3608999999998665, 2.0], [0.0, 0.04, 0.08485281374238572, 0.14832396974191328, 0.23409399821439228, 0.3458323293158109, 0.48497422611928837, 0.6532993188424492, 0.8520563361656232, 1.0822199406774653, 1.3447676379210893, 1.6403658128599756, 1.9696700231256092, 2.3331523739352016, 2.8284271247461903])</code></pre><p>The returned <code>xs</code> and <code>ys</code> contain the points needed for the linear interpolation with an error smaller than the given tolerance. When calling the function, we have set a <code>scan_step</code> of <span>$10^{-4}$</span>. By default this value is computed such that the domain is divided in 100 steps. It is recommeneded to not set a very small value of the scan step. Depending on the desired tolerance, between 100 and 1e4 maximum possible subintervals is desired, otherwise, the execution time will be very small. It is recommendended to set the <code>scan_step</code> value as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain = (0.0, 2.0)</code><code class="nohighlight hljs ansi" style="display:block;">(0.0, 2.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; scan_step_value = (domain[end] - domain[begin]) / 1e4</code><code class="nohighlight hljs ansi" style="display:block;">0.0002</code></pre><p>where the <code>1e4</code> can be the maximum number of points you want.</p><p>We can plot the points <code>xs</code> and <code>ys</code> on top of the function and observe that when <span>$f(x)$</span> varies more, the points are closer, whereas the get further away when they are more linear.</p><img src="0b0eb145.png" alt="Example block output"/><p>Note that even though the second derivative of our function <span>$f(x) = \sqrt{2x}$</span> is not defined at <span>$x = 0$</span> (therefore is not continuous), there is no problem. The function <a href="#AdaptiveStepSize.points_linear"><code>points_linear</code></a> will never evaluate the second derivative at the boundaries defined by the <code>domain</code> parameter.</p><h2 id="Singularities"><a class="docs-heading-anchor" href="#Singularities">Singularities</a><a id="Singularities-1"></a><a class="docs-heading-anchor-permalink" href="#Singularities" title="Permalink"></a></h2><p>A singularity is a point at which the function is not defined or is not well-behaved. A typical example is <span>$|x|$</span>, in which the function is continuous at <span>$x = 0$</span> but not differentiable (the derivative is not continuous at that point). For these kind of functions, we can use <a href="#AdaptiveStepSize.points_linear_singular"><code>points_linear_singular</code></a>. The only difference between this method and <a href="#AdaptiveStepSize.points_linear"><code>points_linear</code></a> is that here we need to pass an extra parameter called <code>singularities</code>. This must be a <code>Vector{T}</code> where <code>T&lt;:Real</code> containing all those singular points. The algorithm will compute the points for each subinterval delimited by this <code>singularities</code> vector.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AdaptiveStepSize.points_linear_singular" href="#AdaptiveStepSize.points_linear_singular"><code>AdaptiveStepSize.points_linear_singular</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">points_linear_singular(f, domain, singularities::Vector{T}, tol::T; scan_step = (domain[end] - domain[begin]) / 100) where T &lt;: Real</code></pre><p>Computes points used for a linear interpolation of the function <code>f</code> in the given <code>domain</code> within a tolerance <code>tol</code>. Manages singular points though the array <code>singularities</code>.</p><p>See <a href="#AdaptiveStepSize.points_linear"><code>points_linear</code></a> for an in depth description of the arguments. This function needs the additional argument <code>singularities</code>. This must be a <code>Vector{T}</code> where <code>T&lt;:Real</code> that contains each singular point.</p><p>A singularity in this case is a point at which the function is not well-behaved, like <code>abs(x)</code> at x = 0, where the function is continuous but not differentiable.</p><p>If the function has several singularities, we can write those in the <code>singularities</code> vector. The function <code>points_linear</code> will be applied at each subinterval. In addition, the second derivative will never be computed at those endpoints, i.e., at the <code>singularities</code> and the <code>domain</code> points. Note that <code>f</code> <strong>will be</strong> evaluated at the endpoints and it should handle those discontinuities properly. It is the user responsability to do so.</p><p><strong>Notes</strong></p><p>If you have a piecewise function, it might be convenient to apply <a href="#AdaptiveStepSize.points_linear"><code>points_linear</code></a> at each interval of the function, instead of passing the <code>singularities</code> vector here. The reason is that the result contains just one big pair <code>xs</code> and <code>ys</code> vectors and it is not aware of the points where piecewise function is not continuous, hence producing undesiderable results in the interpolation.</p><p>The safest bet here is linearly interpolate each region of the piecewise function separately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pmc4/AdaptiveStepSize.jl/blob/4eadb5435284d03585c56f504bc108545203d4e0/src/AdaptiveStepSize.jl#L128-L149">source</a></section></article><p>Hence, let us compute the <code>xs</code> and <code>ys</code> points for the absolute value function <span>$f(x) = |x|$</span>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using AdaptiveStepSize</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x) = abs(x)</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain = (-1.0, 1.0)</code><code class="nohighlight hljs ansi" style="display:block;">(-1.0, 1.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tol = 1e-2</code><code class="nohighlight hljs ansi" style="display:block;">0.01</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; singularities = [0.0,]</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; xs, ys = points_linear_singular(f, domain, singularities, tol; scan_step = 1e-4)</code><code class="nohighlight hljs ansi" style="display:block;">([-1.0, 0.0, 1.0], [1.0, 0.0, 1.0])</code></pre><p>Since this is a simple function made of two lines that intersect at <span>$x = 0$</span>, we get the expected points. Note that if you call <code>points_linear</code> instead of <code>points_linear_singular</code> you will not get the point <span>$(0.0, 0.0)$</span> in the results. It is very unlikely to exactly compute a certain point when doing the scan. That is why passing explicitly the <code>singularities</code> to the former method is preferred. We can plot the results to see how it looks like.</p><img src="86371005.png" alt="Example block output"/><h2 id="Piecewise-functions"><a class="docs-heading-anchor" href="#Piecewise-functions">Piecewise functions</a><a id="Piecewise-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Piecewise-functions" title="Permalink"></a></h2><p>If we have a piecewise function instead, it is more convenient to call <a href="#AdaptiveStepSize.points_linear"><code>points_linear</code></a> at each interval of the function instead of <a href="#AdaptiveStepSize.points_linear_singular"><code>points_linear_singular</code></a> and passing the <code>singularities</code> vector with each case point. This is because the result contains just one big pair <code>xs</code> and <code>ys</code> vectors and it is not aware of the points where piecewise function is not continuous, hence producing undesiderable results in the interpolation.</p><p>To see this in action, let us consider the following piecewise function</p><p class="math-container">\[f(x) = \begin{cases}
    \sin(x) &amp;\text{if } x &lt; 2\pi \\
    (x - 8)^2 &amp;\text{if } 2\pi \leq x \leq 10 \\
    \sqrt{x} - 3 &amp;\text{if } x &gt; 10
\end{cases}\]</p><p>We will consider the domain <span>$[0,\, 20]$</span>. First, we will make use of the <code>points_linear_singular</code> and see why is not convenient. In Julia, we can write this as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using AdaptiveStepSize</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f(x)
           if x &lt; 2π
               return sin(x)
           elseif x &lt;= 10.0
               return (x - 8)^2
           else
               return sqrt(x) - 3
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain = (0.0, 20.0)</code><code class="nohighlight hljs ansi" style="display:block;">(0.0, 20.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tol = 1e-2</code><code class="nohighlight hljs ansi" style="display:block;">0.01</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; singularities = [2π, 10.0]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
  6.283185307179586
 10.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; xs, ys = points_linear_singular(f, domain, singularities, tol; scan_step = 1e-4)</code><code class="nohighlight hljs ansi" style="display:block;">([0.0, 0.43549999999996836, 0.7738999999999311, 1.075499999999898, 1.3614999999998665, 1.6443999999998353, 1.9276999999998041, 2.2200000000002604, 2.5370000000009294, 2.912200000001721  …  8.484285307174456, 8.68438530717399, 8.884485307173524, 9.084585307173057, 9.284685307172591, 9.484785307172125, 9.684885307171658, 10.0, 13.181199999992586, 20.0], [0.0, 0.4218637836925768, 0.6989297890393922, 0.8798279065966838, 0.9781773602189574, 0.9972924723126391, 0.9369830917527852, 0.7965654722359292, 0.5684269858028858, 0.22738612873312744  …  0.2345322587450576, 0.4683832486756367, 0.7823142586058426, 1.1763252885356752, 1.6504163384651345, 2.2045874083942207, 2.8388384983229336, 4.0, 0.6305922381882252, 1.4721359549995796])</code></pre><p>If we plot now the result over the piecewise <span>$f(x)$</span> function, we get:</p><img src="dbcbf7f8.png" alt="Example block output"/><p>What is happening here is that the endpoints of each segment of the piecewise function do not always have a point (blue circle). If we apply linear interpolation to the whole result, we will get wrong results near those endpoints. This is because <a href="#AdaptiveStepSize.points_linear_singular"><code>points_linear_singular</code></a> is suitable only for continuous functions. To fix this, we have to call <a href="#AdaptiveStepSize.points_linear"><code>points_linear</code></a> once for each segment:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using AdaptiveStepSize</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f(x)
           if x &lt; 2π
               return sin(x)
           elseif x &lt;= 10.0
               return (x - 8)^2
           else
               return sqrt(x) - 3
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain1 = (0.0, 2π - 1e-15) # Notice how 2π is not exactly included here</code><code class="nohighlight hljs ansi" style="display:block;">(0.0, 6.283185307179585)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain2 = (2π, 10.0)</code><code class="nohighlight hljs ansi" style="display:block;">(6.283185307179586, 10.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain3 = (10.0 + 1e-15, 20.0) # The same happens with x = 10.0, it is an open interval</code><code class="nohighlight hljs ansi" style="display:block;">(10.000000000000002, 20.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tol = 1e-2;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; xs1, ys1 = points_linear(f, domain1, tol; scan_step = 1e-4)</code><code class="nohighlight hljs ansi" style="display:block;">([0.0, 0.43549999999996836, 0.7738999999999311, 1.075499999999898, 1.3614999999998665, 1.6443999999998353, 1.9276999999998041, 2.2200000000002604, 2.5370000000009294, 2.912200000001721, 3.436700000002828, 3.798700000003592, 4.110300000003759, 4.400300000003083, 4.683300000002424, 4.9662000000017645, 5.2537000000010945, 5.559300000000382, 6.283185307179585], [0.0, 0.4218637836925768, 0.6989297890393922, 0.8798279065966838, 0.9781773602189574, 0.9972924723126391, 0.9369830917527852, 0.7965654722359292, 0.5684269858028858, 0.22738612873312744, -0.2908425577262733, -0.6108291161898552, -0.8241542879031629, -0.9516942309279802, -0.9995769454427188, -0.967962526480151, -0.8570339020834412, -0.6623006839179572, -1.133107779529596e-15])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; xs2, ys2 = points_linear(f, domain2, tol; scan_step = 1e-4)</code><code class="nohighlight hljs ansi" style="display:block;">([6.283185307179586, 6.48328530717912, 6.6833853071786535, 6.883485307178187, 7.083585307177721, 7.2836853071772545, 7.483785307176788, 7.683885307176322, 7.883985307175855, 8.084085307175389, 8.284185307174923, 8.484285307174456, 8.68438530717399, 8.884485307173524, 9.084585307173057, 9.284685307172591, 9.484785307172125, 9.684885307171658, 10.0], [2.947452689484052, 2.3004234594187367, 1.7334742493530486, 1.246605059286987, 0.8398158892205523, 0.5131067391537443, 0.266477609086563, 0.09992849901900844, 0.01345940895108062, 0.00707033888277954, 0.0807612888141052, 0.2345322587450576, 0.4683832486756367, 0.7823142586058426, 1.1763252885356752, 1.6504163384651345, 2.2045874083942207, 2.8388384983229336, 4.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; xs3, ys3 = points_linear(f, domain3, tol; scan_step = 1e-4)</code><code class="nohighlight hljs ansi" style="display:block;">([10.000000000000002, 13.181199999992588, 20.0], [0.16227766016837952, 0.6305922381882252, 1.4721359549995796])</code></pre><p>Note that when defining the domains, we are adding or substracting a very small number (<code>1e-15</code>). This is because the first segment is valid for <span>$x &lt; 2\pi$</span>, so the first domain must be open on the right side (it cannot include the point <span>$2\pi$</span>). Mathematically this is represented by the interval <span>$[0,\, 2\pi)$</span>. On the computer, we can do the same by subtracting a very small number, i.e., <code>domain1 = [0.0, 2π - 1e-15]</code>. The same happens with the last segment that is only valid for <span>$x &gt; 10$</span>. We cannot include the point <span>$10$</span> on <code>domain3</code>. That is why we represent it as <code>domain3 = [10.0 + 1e-15, 20.0]</code>. When we plot the results we explicitly get the endpoints.</p><img src="45c1532e.png" alt="Example block output"/><p>We can now apply a linear interpolation to each segment and the result will be correct.</p><div class="admonition is-info" id="Use-the-desired-tolerance-c23c559fc7f13b48"><header class="admonition-header">Use the desired tolerance<a class="admonition-anchor" href="#Use-the-desired-tolerance-c23c559fc7f13b48" title="Permalink"></a></header><div class="admonition-body"><p>In all of these examples we are using a high tolerance of <code>tol = 1e-2</code> for the sake of clarity on the figures. If you want something more precise like <code>tol = 1e-6</code> you can do it, bear in mind that when visualizing it, you have a bunch of points close together that you cannot distinguish them individually from the plot.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../theory/">Theory »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.0 on <span class="colophon-date" title="Sunday 11 May 2025 17:41">Sunday 11 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
