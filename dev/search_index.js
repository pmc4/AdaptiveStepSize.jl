var documenterSearchIndex = {"docs":
[{"location":"linear_interpolation/#Linear-interpolation","page":"Linear interpolation","title":"Linear interpolation","text":"","category":"section"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"To compute the points of a linear interpolation for a given function f(x), we can use the points_linear function.","category":"page"},{"location":"linear_interpolation/#AdaptiveStepSize.points_linear","page":"Linear interpolation","title":"AdaptiveStepSize.points_linear","text":"points_linear(f, domain, tol::T; scan_step = (domain[end] - domain[begin]) / 100) where T <: Real\n\nComputes points used for a linear interpolation of the function f in the given domain within a tolerance tol.\n\nSee also points_linear_singular for managing singular points.\n\nArguments\n\nf: The function used for the linear interpolation. It must be of the form of f(x), where x is a number.\ndomain: a tuple or array representing the interpolation domain, e.g., the tuple (a, b).\ntol::T where T <: Real: the desired tolerance of the points. The real value of the function at any point xᵢ minus the aproximation will be smaller than tol, i.e., |f(xᵢ) - yᵢ| < tol.\n\nKeywords\n\nscan_step: Minimum step size that will be used to scan the whole domain. The returned points will have at least a spacing of scan_step. Very small values will produce a very long execution time. By default it will divide the domain in 100 intervals.\n\nReturns\n\n(xs, ys): A tuple containing two arrays of points, xs for the independent variable and ys for the computed values of the function.\n\nNotes\n\nThe function f must have a continuous second derivative in order to compute the linear interpolation error. This second derivative is computed using Enzyme's automatic differentiation.\n\nIf the returned (xs, ys) contains just the endpoints, try decreasing the scan_step size and/or increasing the tolerance tol.\n\nIf the execution time of a single call to the function f is quite long, this adaptive method might not be suitable.\n\n\n\n\n\n","category":"function"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"For example, let us apply this function to f(x) = sqrt2x on the interval 0 2 with a tolerance of 10^-2.","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"using AdaptiveStepSize\nf(x) = 2 * sqrt(x)\ndomain = (0.0, 2.0)\ntol = 1e-2\nxs, ys = points_linear(f, domain, tol; scan_step = 1e-4)","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"The returned xs and ys contain the points needed for the linear interpolation with an error smaller than the given tolerance. When calling the function, we have set a scan_step of 10^-4. By default this value is computed such that the domain is divided in 100 steps. It is recommeneded to not set a very small value of the scan step. Depending on the desired tolerance, between 100 and 1e4 maximum possible subintervals is desired, otherwise, the execution time will be very small. It is recommendended to set the scan_step value as","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"domain = (0.0, 2.0)\nscan_step_value = (domain[end] - domain[begin]) / 1e4","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"where the 1e4 can be the maximum number of points you want.","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"We can plot the points xs and ys on top of the function and observe that when f(x) varies more, the points are closer, whereas the get further away when they are more linear.","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"fig # hide","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"Note that even though the second derivative of our function f(x) = sqrt2x is not defined at x = 0 (therefore is not continuous), there is no problem. The function points_linear will never evaluate the second derivative at the boundaries defined by the domain parameter.","category":"page"},{"location":"linear_interpolation/#Singularities","page":"Linear interpolation","title":"Singularities","text":"","category":"section"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"A singularity is a point at which the function is not defined or is not well-behaved. A typical example is x, in which the function is continuous at x = 0 but not differentiable (the derivative is not continuous at that point). For these kind of functions, we can use points_linear_singular. The only difference between this function and points_linear is that here we need to pass an extra parameter called singularities. This must be a Vector{T} where T<:Real containing all those singular points. The algorithm will compute the points for each subinterval delimited by this singularities vector.","category":"page"},{"location":"linear_interpolation/#AdaptiveStepSize.points_linear_singular","page":"Linear interpolation","title":"AdaptiveStepSize.points_linear_singular","text":"points_linear_singular(f, domain, singularities::Vector{T}, tol::T; scan_step = (domain[end] - domain[begin]) / 100) where T <: Real\n\nComputes points used for a linear interpolation of the function f in the given domain within a tolerance tol. Manages singular points though the array singularities.\n\nSee points_linear for an in depth description of the arguments. This function needs the additional argument singularities. This must be a Vector{T} where T<:Real that contains each singular point.\n\nA singularity in this case is a point at which the function is not well-behaved, like abs(x) at x = 0, where the function is continuous but not differentiable.\n\nIf the function has several singularities, we can write those in the singularities vector. The function points_linear will be applied at each subinterval. In addition, the second derivative will never be computed at those endpoints, i.e., at the singularities and the domain points. Note that f will be evaluated at the endpoints and it should handle those discontinuities properly. It is the user responsability to do so.\n\nNotes\n\nIf you have a piecewise function, it might be convenient to apply points_linear at each interval of the function, instead of passing the singularities vector here. The reason is that the result contains just one big pair xs and ys vectors and it is not aware of the points where piecewise function is not continuous, hence producing undesiderable results in the interpolation.\n\nThe safest bet here is linearly interpolate each region of the piecewise function separately.\n\n\n\n\n\n","category":"function"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"Hence, let us compute the xs and ys points for the absolute value function f(x) = x.","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"using AdaptiveStepSize\nf(x) = abs(x)\ndomain = (-1.0, 1.0)\ntol = 1e-2\nsingularities = [0.0,]\nxs, ys = points_linear_singular(f, domain, singularities, tol; scan_step = 1e-4)","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"Since this is a simple function made of two lines that intersect at x = 0, we get the expected points. Note that if you call points_linear instead of points_linear_singular you will not get the point (00 00) in the results. It is very unlikely to exactly compute a certain point when doing the scan. That is why passing explicitly the singularities to the former method is preferred. We can plot the results to see how it looks like.","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"fig # hide","category":"page"},{"location":"linear_interpolation/#Piecewise-functions","page":"Linear interpolation","title":"Piecewise functions","text":"","category":"section"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"If we have a piecewise function instead, it is more convenient to call points_linear at each interval of the function instead of points_linear_singular and passing the singularities vector with each case point. This is because the result contains just one big pair xs and ys vectors and it is not aware of the points where piecewise function is not continuous, hence producing undesiderable results in the interpolation.","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"To see this in action, let us consider the following piecewise function","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"f(x) = begincases\n    sin(x) textif  x  2pi \n    (x - 8)^2 textif  2pi leq x leq 10 \n    sqrtx - 3 textif  x  10\nendcases","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"We will consider the domain 0 20. First, we will make use of the points_linear_singular and see why is not convenient. In Julia, we can write this as","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"using AdaptiveStepSize\n\nfunction f(x)\n    if x < 2π\n        return sin(x)\n    elseif x <= 10.0\n        return (x - 8)^2\n    else\n        return sqrt(x) - 3\n    end\nend\n\ndomain = (0.0, 20.0)\ntol = 1e-2\nsingularities = [2π, 10.0]\nxs, ys = points_linear_singular(f, domain, singularities, tol; scan_step = 1e-4)","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"If we plot now the result over the piecewise f(x) function, we get:","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"plot() # hide","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"What is happening here is that the endpoints of each segment of the piecewise function do not always have a point (blue circle). If we apply linear interpolation to the whole result, we will get wrong results near those endpoints. This is because points_linear_singular is suitable only for continuous functions. To fix this, we have to call points_linear once for each segment:","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"using AdaptiveStepSize\n\nfunction f(x)\n    if x < 2π\n        return sin(x)\n    elseif x <= 10.0\n        return (x - 8)^2\n    else\n        return sqrt(x) - 3\n    end\nend\n\ndomain1 = (0.0, 2π - 1e-15)\ndomain2 = (2π, 10.0)\ndomain3 = (10.0 + 1e-15, 20.0)\n\ntol = 1e-2;\nxs1, ys1 = points_linear(f, domain1, tol; scan_step = 1e-4)\nxs2, ys2 = points_linear(f, domain2, tol; scan_step = 1e-4)\nxs3, ys3 = points_linear(f, domain3, tol; scan_step = 1e-4)","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"When we plot the results we explicitly get the endpoints.","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"plot2() # hide","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"We can now apply a linear interpolation to each segment and the result will be correct.","category":"page"},{"location":"linear_interpolation/","page":"Linear interpolation","title":"Linear interpolation","text":"note: Use the desired tolerance\nIn all of these examples we are using a high tolerance of tol = 1e-2 for the sake of clarity on the figures. If you want something more precise like tol = 1e-6 you can do it, bear in mind that when visualizing it, you have a bunch of points close together that you cannot distinguish them individually from the plot.","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"In this page we briefly describe each interpolation method and how the error estimation is computed. For usage of the methods, go to the Interpolation methods section.","category":"page"},{"location":"theory/#theory_linear_interpolation","page":"Theory","title":"Linear interpolation","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Given a function f(x) defined on a domain X in mathbbR, and given two points (x_0 y_0) and (x_1 y_1) where x_i in X and y_i equiv f(x_i), we can approximate the function in the interval x_0 x_1 with the following second order polynomial:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"    p(x) = f(x_0) + dfracf(x_1) - f(x0)x_1 - x_0 (x - x_0) ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The error of the approximation is defined as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"    R_T(x) = f(x) - p(x) ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"If f has a continuous second derivative, i.e., is a function of class C^2, then error is bounded by","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"    leftR_Tright leq dfrac(x_1 - x_0)^28 max_x_0 leq x leq x_1 leftf^primeprime(x)right ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In addition, we can further divide f(x) in several subintervals, delimited by lbrace x_i rbrace_i=0^n and apply a linear interpolation to each of the subintervals.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"If the function does not have a continuous second derivative, we cannot use the previous equation to estimate the error bound. However, if the discontinuities are removable discontinuities or jump discontinuities at different points d_i, we can locally apply the linear interpolation at the open intervals (d_i-1 d_i).","category":"page"},{"location":"#AdaptiveStepSize","page":"Home","title":"AdaptiveStepSize","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AdaptiveStepSize is a Julia package used to obtain the minimum amount of points needed for the interpolation of a function in the given interval within the desired tolerance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Given a function f(x), defined on the interval a b, and an interpolation method, it subdivides the interval with the maximum spacing between points such that the interpolation has an error smaller than the given tolerance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the moment, only linear interpolation is implemented. Any contribution is welcomed to further implement other methods.","category":"page"},{"location":"#Aim-of-this-package","page":"Home","title":"Aim of this package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is useful if you have a function that takes a bit of time to execute (less than a second per call, for example) and you need to interpolate it to reduce the execution time. This is a possible use case when such function must be called hundreds or thousands of times.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If your function takes a lot of time to execute, it may not be worth to use the package, since it computes the value of the function a lot of times in the given interval.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Check the Usage section to see the available options and instructions.\nThe Theory section contains a brief explanation on how the interpolation method works and how the error is estimated.","category":"page"},{"location":"internals/#API","page":"API","title":"API","text":"","category":"section"},{"location":"internals/","page":"API","title":"API","text":"Here we write all the methods defined in AdaptiveStepSize.jl, both public and private, since Documenter will complain if the private ones are not included. Use those at your own risk and do not expect consistency between versions in private methods.","category":"page"},{"location":"internals/","page":"API","title":"API","text":"","category":"page"},{"location":"internals/#AdaptiveStepSize.AdaptiveStepSize","page":"API","title":"AdaptiveStepSize.AdaptiveStepSize","text":"Main module for AdaptiveStepSize.jl, a Julia package used to obtain the minimum amount of points needed for the interpolation of a function in the given interval within the desired tolerance.\n\nOnly linear interpolation methods are implemented for now. Any contribution is wecolmed to further implement other methods.\n\nCheck the docs for more information.\n\n\n\n\n\n","category":"module"},{"location":"internals/#AdaptiveStepSize._DIRECTION_1D_X","page":"API","title":"AdaptiveStepSize._DIRECTION_1D_X","text":"Direction of the derivative. Derivate w.r.t. positive x in 1 dimension.\n\n\n\n\n\n","category":"constant"},{"location":"internals/#AdaptiveStepSize._MIN_FLOAT","page":"API","title":"AdaptiveStepSize._MIN_FLOAT","text":"Smallest value for the Float64 type.\n\n\n\n\n\n","category":"constant"},{"location":"internals/#AdaptiveStepSize.points_linear-Union{Tuple{T}, Tuple{Any, Any, T}} where T<:Real","page":"API","title":"AdaptiveStepSize.points_linear","text":"points_linear(f, domain, tol::T; scan_step = (domain[end] - domain[begin]) / 100) where T <: Real\n\nComputes points used for a linear interpolation of the function f in the given domain within a tolerance tol.\n\nSee also points_linear_singular for managing singular points.\n\nArguments\n\nf: The function used for the linear interpolation. It must be of the form of f(x), where x is a number.\ndomain: a tuple or array representing the interpolation domain, e.g., the tuple (a, b).\ntol::T where T <: Real: the desired tolerance of the points. The real value of the function at any point xᵢ minus the aproximation will be smaller than tol, i.e., |f(xᵢ) - yᵢ| < tol.\n\nKeywords\n\nscan_step: Minimum step size that will be used to scan the whole domain. The returned points will have at least a spacing of scan_step. Very small values will produce a very long execution time. By default it will divide the domain in 100 intervals.\n\nReturns\n\n(xs, ys): A tuple containing two arrays of points, xs for the independent variable and ys for the computed values of the function.\n\nNotes\n\nThe function f must have a continuous second derivative in order to compute the linear interpolation error. This second derivative is computed using Enzyme's automatic differentiation.\n\nIf the returned (xs, ys) contains just the endpoints, try decreasing the scan_step size and/or increasing the tolerance tol.\n\nIf the execution time of a single call to the function f is quite long, this adaptive method might not be suitable.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AdaptiveStepSize.points_linear_singular-Union{Tuple{T}, Tuple{Any, Any, Vector{T}, T}} where T<:Real","page":"API","title":"AdaptiveStepSize.points_linear_singular","text":"points_linear_singular(f, domain, singularities::Vector{T}, tol::T; scan_step = (domain[end] - domain[begin]) / 100) where T <: Real\n\nComputes points used for a linear interpolation of the function f in the given domain within a tolerance tol. Manages singular points though the array singularities.\n\nSee points_linear for an in depth description of the arguments. This function needs the additional argument singularities. This must be a Vector{T} where T<:Real that contains each singular point.\n\nA singularity in this case is a point at which the function is not well-behaved, like abs(x) at x = 0, where the function is continuous but not differentiable.\n\nIf the function has several singularities, we can write those in the singularities vector. The function points_linear will be applied at each subinterval. In addition, the second derivative will never be computed at those endpoints, i.e., at the singularities and the domain points. Note that f will be evaluated at the endpoints and it should handle those discontinuities properly. It is the user responsability to do so.\n\nNotes\n\nIf you have a piecewise function, it might be convenient to apply points_linear at each interval of the function, instead of passing the singularities vector here. The reason is that the result contains just one big pair xs and ys vectors and it is not aware of the points where piecewise function is not continuous, hence producing undesiderable results in the interpolation.\n\nThe safest bet here is linearly interpolate each region of the piecewise function separately.\n\n\n\n\n\n","category":"method"}]
}
